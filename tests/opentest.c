#!/usr/bin/env python

# coding: utf-8

# Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000
#  The Regents of the University of California.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that: (1) source code distributions
# retain the above copyright notice and this paragraph in its entirety, (2)
# distributions including binary code include the above copyright notice and
# this paragraph in its entirety in the documentation or other materials
# provided with the distribution, and (3) all advertising materials mentioning
# features or use of this software display the following acknowledgement:
# ``This product includes software developed by the University of California,
# Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
# the University nor the names of its contributors may be used to endorse
# or promote products derived from this software without specific prior
# written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

from __future__ import absolute_import, division, print_function

import sys
import os
import getopt
import ctypes as ct

import libpcap as pcap

#ifndef lint
copyright = "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, "\
            "1995, 1996, 1997, 2000\n\
            "The Regents of the University of California.  "\
            "All rights reserved.\n"
#endif

MAXIMUM_SNAPLEN = 65535


def main(argv):
{
    global program_name
    program_name = os.path.basename(argv[0])

    register int op;
    register char *cp, *device;
    int dorfmon, dopromisc, snaplen, useactivate, bufsize;
    pcap_t *pd;
    int status = 0;

    device = NULL;
    dorfmon = 0;
    dopromisc = 0;
    snaplen = MAXIMUM_SNAPLEN;
    bufsize = 0;
    useactivate = 0;

    opterr = 0;
    while ((op = getopt(argv, "i:Ips:aB:")) != -1) {
        switch (op) {

        case 'i':
            device = optarg;
            break;

        case 'I':
            dorfmon = 1;
            useactivate = 1;    /* required for rfmon */
            break;

        case 'p':
            dopromisc = 1;
            break;

        case 's': {
            char *end;

            snaplen = strtol(optarg, &end, 0);
            if (optarg == end || *end != '\0'
                || snaplen < 0 || snaplen > MAXIMUM_SNAPLEN)
                error("invalid snaplen %s", optarg);
            else if (snaplen == 0)
                snaplen = MAXIMUM_SNAPLEN;
            break;
        }

        case 'B':
            bufsize = atoi(optarg)*1024;
            if (bufsize <= 0)
                error("invalid packet buffer size %s", optarg);
            useactivate = 1;    /* required for bufsize */
            break;

        case 'a':
            useactivate = 1;
            break;

        default:
            usage();
            /* NOTREACHED */
        }
    }

    ebuf = ct.create_string_buffer(pcap.PCAP_ERRBUF_SIZE)

    if (device == NULL)
    {
        device = pcap_lookupdev(ebuf);
        if (device == NULL)
            error("pcap_lookupdev failed: %s", ebuf);
    }
    if (useactivate)
    {
        pd = pcap.create(device, ebuf)
        if not pd:
            error("%s: pcap_create failed: %s", device, ebuf);
        status = pcap_set_snaplen(pd, snaplen);
        if (status != 0)
            error("%s: pcap_set_snaplen failed: %s",
                device, pcap.statustostr(status).decode("utf-8", "ignore"));
        if (dopromisc) {
            status = pcap_set_promisc(pd, 1);
            if (status != 0)
                error("%s: pcap_set_promisc failed: %s",
                    device, pcap.statustostr(status).decode("utf-8", "ignore"));
        }
        if (dorfmon) {
            status = pcap_set_rfmon(pd, 1);
            if (status != 0)
                error("%s: pcap_set_rfmon failed: %s",
                    device, pcap.statustostr(status).decode("utf-8", "ignore"));
        }
        status = pcap_set_timeout(pd, 1000);
        if (status != 0)
            error("%s: pcap_set_timeout failed: %s",
                device, pcap.statustostr(status).decode("utf-8", "ignore"));
        if (bufsize != 0) {
            status = pcap_set_buffer_size(pd, bufsize);
            if (status != 0)
                error("%s: pcap_set_buffer_size failed: %s",
                    device, pcap.statustostr(status).decode("utf-8", "ignore"));
        }
        status = pcap.activate(pd)
        if status < 0:
        {
            /*
             * pcap.activate() failed.
             */
            error("%s: %s\n(%s)", device,
                pcap.statustostr(status).decode("utf-8", "ignore"), pcap.geterr(pd).decode("utf-8", "ignore"));
        }
        else if (status > 0)
        {
            /*
             * pcap.activate() succeeded, but it's warning us
             * of a problem it had.
             */
            warning("%s: %s\n(%s)", device,
                pcap.statustostr(status).decode("utf-8", "ignore"), pcap.geterr(pd).decode("utf-8", "ignore"));
        }
        else
            printf("%s opened successfully\n", device);
    }
    else
    {
        *ebuf = '\0';
        pd = pcap.open_live(device, 65535, 0, 1000, ebuf);
        if not pd:
            error("%s", ebuf);
        else if (*ebuf)
            warning("%s", ebuf);
        else
            printf("%s opened successfully\n", device);
    }
    pcap.close(pd)

    return 1 if status < 0 else 0


def usage():

    global program_name
    print("Usage: {} [ -Ipa ] [ -i interface ] [ -s snaplen ] "
          "[ -B bufsize ]".format(program_name), file=sys.stderr)
    sys.exit(1)


def error(fmt, *args):

    global program_name
    print("{}: ".format(program_name), end="", file=sys.stderr)
    print(fmt.format(*args), end="", file=sys.stderr)
    if fmt and fmt[-1] != '\n':
        print(file=sys.stderr)
    sys.exit(1)


def warning(fmt, *args):

    global program_name
    print("{}: WARNING: ".format(program_name), end="", file=sys.stderr)
    print(fmt.format(*args), end="", file=sys.stderr)
    if fmt and fmt[-1] != '\n':
        print(file=sys.stderr)


sys.exit(main(sys.argv) or 0)


# eof
